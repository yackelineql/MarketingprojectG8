# -*- coding: utf-8 -*-
"""d_modelo2 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qk9uAMRIl5uZlLwnoadgQNcF_rhAGHst

# **Conexión al Drive**
"""

from google.colab import drive
drive.mount('/content/drive')

"""## **Acceso a Archivos del Proyecto en Google Drive**"""

import sys
import os

path='/content/drive/MyDrive/cod/marketing/MarketingprojectG8/'

# Add the path to sys.path
sys.path.append(path)
os.chdir(path)
print(os.listdir())

import numpy as np
import pandas as pd
import sqlite3 as sql
import scipy as sp
from scipy import sparse
from sklearn.preprocessing import MinMaxScaler
from ipywidgets import interact ## para análisis interactivo
from sklearn import neighbors ### basado en contenido un solo producto consumido
import joblib
import ipywidgets as widgets
import tensorflow
from tensorflow.keras import layers, models
from sklearn.metrics.pairwise import cosine_similarity
from IPython.display import display
import ipywidgets as widgets
from sklearn.neighbors import NearestNeighbors
from sklearn.decomposition import TruncatedSVD
from IPython.display import display

!pip install lightfm
from lightfm import LightFM
from lightfm.datasets import fetch_movielens
from lightfm.data import Dataset

#### conectar_base_de_Datos

con=sql.connect("movies2")
cur=con.cursor()

#### ver tablas disponibles en base de datos ###

cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
tables = cur.fetchall()

print("Tablas en la base de datos copiada:")
for table in tables:
    print(table)

"""#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
#**3. Sistema de recomendación basado en contenido KNN con base en todo lo visto por el usuario**
#//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
"""

# Ejecutar la consulta SQL y cargar los datos en un DataFrame
try:
  movies = pd.read_sql_query("SELECT * FROM movies_genres", con)
except Exception as e:
  print(f"Error al leer la tabla: {e}")

# Mostrar información sobre el DataFrame
movies.info()

# Convertir la columna 'year' a tipo entero
movies['year'] = pd.to_numeric(movies['year'], errors='coerce').astype('Int64')
# 'coerce' convierte valores no numéricos a NaN, 'Int64' permite valores nulos

# Cargar Dataframe escalado previamente guardado, con dummies CON año de estreno

peliculas_dummy1=joblib.load('peliculas_dummy01')

# ¿A qué usuarios se les presentaran las recomendaciones?
try:
    usuarios = pd.read_sql('select distinct (userId) as user_id from full_tabla',con)
except sql.Error as e:
    print(f"Error al obtener los usuarios: {e}")

# Función que permite seleccionar al usuario y muestra películas recomendadas,según lo que ha visto.

def recomendar1(user_id=list(sorted(usuarios['user_id'].value_counts().index))):
    """
    Recomienda películas a un usuario basándose en su historial de visualización.

    Args:
        user_id (int, optional): ID del usuario para el que se generan las recomendaciones.
                                  Por defecto, se selecciona el usuario más activo.

    Returns:
        pandas.DataFrame: DataFrame que contiene las películas recomendadas con su título y ID.
    """

    # Seleccionar solo los ratings del usuario seleccionado.
    ratings = pd.read_sql('select * from ratings_dt where userId=:user', con, params={'user': user_id})

    # Convertir las películas del usuario a un array.
    user_movieId = ratings['movieId'].to_numpy()

    # Agregar la columna de movieId y título al DataFrame 'peliculas_dummy1'
    # para filtrar y mostrar el nombre.
    peliculas_dummy1[['movieId', 'title']] = movies[['movieId', 'title']]

    # Filtrar películas calificadas por el usuario.
    movies_rated = peliculas_dummy1[peliculas_dummy1['movieId'].isin(user_movieId)]

    # Eliminar columna de ID y título de película del DataFrame 'movies_rated'.
    movies_rated = movies_rated.drop(columns=['movieId', 'title'])

    # Agregar una columna "indice" con valor 1 para usar groupby y obtener una tabla de centroide.
    movies_rated["indice"] = 1

    # Calcular el centroide o perfil del usuario (promedio de las características de las películas vistas).
    centroide = movies_rated.groupby("indice").mean()

    # Filtrar películas que no se han visto.
    movies_no_rated = peliculas_dummy1[~peliculas_dummy1['movieId'].isin(user_movieId)]

    # Eliminar ID y nombre de películas no vistas del DataFrame 'movies_no_rated'.
    movies_no_rated = movies_no_rated.drop(columns=['movieId', 'title'])

    # Entrenar el modelo KNN con películas no vistas para que recomiende las más cercanas al centroide.
    model = neighbors.NearestNeighbors(n_neighbors=11, metric='cosine')
    model.fit(movies_no_rated)

    # Obtener la distancia y los índices de las películas más cercanas al centroide.
    dist, idlist = model.kneighbors(centroide)

    # Extraer los índices de las películas recomendadas.
    ids = idlist[0]

    # Obtener el título y el ID de las películas recomendadas usando los índices.
    recomend_movies = movies.loc[ids][['title', 'movieId']]

    # Obtener el título y el ID de las películas que el usuario ya ha visto (no se usa en la salida final).
    leidos = movies[movies['movieId'].isin(user_movieId)][['title', 'movieId']]

    # Devolver el DataFrame con las películas recomendadas.
    return recomend_movies

# Crear un widget interactivo para la función 'recomendar1'.
print(interact(recomendar1))

# Cargamos el DataFrame de películas con variables dummy (sin año de estreno)

peliculas_dummy2=joblib.load('peliculas_dummy02')

# Obtenemos la lista de usuarios únicos para generar recomendaciones

try:
    usuarios=pd.read_sql('select distinct (userId) as user_id from full_tabla',con)
except sql.Error as e:
    print(f"Error al obtener los usuarios: {e}")

# Funcion que permite seleccionar el usuario y muestra peliculas recomendadas, segun lo que el ha visto

def recomendar2(user_id=list(sorted(usuarios['user_id'].value_counts().index))):
    """
    Esta función recomienda películas a un usuario basándose en su historial de visualización.

    Args:
        user_id (int, optional): ID del usuario para el que se generan las recomendaciones.
                                  Por defecto, se selecciona el usuario más activo.

    Returns:
        pandas.DataFrame: DataFrame que contiene las películas recomendadas con su título y ID.
    """

    ## Seleccionar solo los ratings del usuario seleccionado.
    ratings=pd.read_sql('select * from ratings_dt where userId=:user',con, params={'user':user_id})

    ### Convertir las películas que el usuario ha calificado a un array.
    user_movieId =ratings['movieId'].to_numpy()

    ### Agregar las columnas de movieId y título al DataFrame 'peliculas_dummy2'
    ### para poder filtrar y mostrar el nombre de las películas.
    peliculas_dummy2[['movieId','title']]=movies[['movieId','title']]

    ### Filtrar 'peliculas_dummy2' para obtener solo las películas calificadas por el usuario.
    movies_rated=peliculas_dummy2[peliculas_dummy2['movieId'].isin(user_movieId)]

    ## Eliminar las columnas de movieId y título del DataFrame 'movies_rated',
    ## ya que no se necesitan para el cálculo de KNN.
    movies_rated=movies_rated.drop(columns=['movieId','title'])

    ## Agregar una columna "indice" con valor 1 para usar groupby
    ## y obtener una tabla con el perfil del usuario (centroide).
    movies_rated["indice"]=1

    ## Calcular el centroide o perfil del usuario (promedio de las características
    ## de las películas que ha visto).
    centroide=movies_rated.groupby("indice").mean()


    ### Filtrar 'peliculas_dummy2' para obtener las películas que el usuario NO ha visto.
    movies_no_rated=peliculas_dummy2[~peliculas_dummy1['movieId'].isin(user_movieId)]

    ## Eliminar las columnas de movieId y título del DataFrame 'movies_no_rated'.
    movies_no_rated=movies_no_rated.drop(columns=['movieId','title'])

    ### Entrenar el modelo KNN con las películas que el usuario NO ha visto
    ### para que recomiende las más cercanas al perfil del usuario (centroide).
    model=neighbors.NearestNeighbors(n_neighbors=11, metric='cosine') # Crear modelo KNN con 11 vecinos y métrica coseno.
    model.fit(movies_no_rated) # Entrenar el modelo con las películas no vistas.

    ## Obtener la distancia y los índices de las películas más cercanas al centroide.
    dist, idlist = model.kneighbors(centroide)

    ## Extraer los índices de las películas recomendadas del array anidado 'idlist'.
    ids=idlist[0]

    ## Obtener el título y el movieId de las películas recomendadas usando los índices.
    recomend_movies=movies.loc[ids][['title','movieId']]

    ## Obtener el título y el movieId de las películas que el usuario ya ha visto
    ## (no se usa en la salida final, pero puede ser útil para análisis).
    leidos=movies[movies['movieId'].isin(user_movieId)][['title','movieId']]

    ## Devolver el DataFrame con las películas recomendadas.
    return recomend_movies

## Crear un widget interactivo para la función 'recomendar2',
## permitiendo al usuario seleccionar un 'user_id' y ver las recomendaciones.
print(interact(recomendar2))

"""#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
# **4. Sistema de recomendación de filtro colaborativo**
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#

## **sistemas de recomendación bajo el concepto de filtrado colaborativo basado en redes neuronales.**
"""

# Cargar los datos necesarios
ratings = pd.read_sql("SELECT * FROM ratings_dt", con)  # Datos de calificaciones
#movies = pd.read_sql("SELECT * FROM movies", con)  # Datos de películas
movies_genres = pd.read_sql("SELECT * FROM movies_genres", con)  # Géneros de películas

# Crear la matriz de usuario-producto
user_movie_matrix = ratings.pivot_table(index='userId', columns='movieId', values='rating').fillna(0)

# Normalizar los datos (opcional, pero puede mejorar el rendimiento)
user_movie_matrix_normalized = user_movie_matrix - user_movie_matrix.mean(axis=1).values.reshape(-1, 1)

# Crear el Autoencoder
input_layer = layers.Input(shape=(user_movie_matrix.shape[1],))
encoded = layers.Dense(128, activation='relu')(input_layer)
encoded = layers.Dense(64, activation='relu')(encoded)
decoded = layers.Dense(128, activation='relu')(encoded)
decoded = layers.Dense(user_movie_matrix.shape[1], activation='sigmoid')(decoded)

autoencoder = models.Model(input_layer, decoded)

# Compilar el modelo
autoencoder.compile(optimizer='adam', loss='mean_squared_error')

# Entrenar el modelo
autoencoder.fit(user_movie_matrix_normalized, user_movie_matrix_normalized, epochs=50, batch_size=256, shuffle=True)

# Obtener las representaciones latentes (codificadas)
encoded_ratings = autoencoder.layers[1].output

# Crear un modelo para la predicción de calificaciones
predict_model = models.Model(input_layer, encoded_ratings)

# Hacer predicciones para todos los usuarios
predictions = predict_model.predict(user_movie_matrix_normalized)

# Función para recomendar películas para un usuario
def recommend_autoencoder(user_id, n_recommendations=10):
    user_idx = user_movie_matrix.index.get_loc(user_id)

    # Obtener las predicciones de calificación para este usuario
    user_predictions = predictions[user_idx, :]

    # Ordenar las películas en función de la predicción y seleccionar las mejores
    recommendations = user_predictions.argsort()[-n_recommendations:][::-1]

    # Obtener los títulos de las películas recomendadas
    recommended_movie_ids = user_movie_matrix.columns[recommendations]
    recommended_titles = movies[movies['movieId'].isin(recommended_movie_ids)]['title'].values
    return recommended_titles

# Crear un widget de selección para el usuario
user_selector = widgets.Dropdown(
    options=[(user, user) for user in user_movie_matrix.index],
    description='User ID:',
    disabled=False
)

# Crear un control para ajustar el número de recomendaciones
recommendations_count = widgets.IntSlider(
    value=10,
    min=1,
    max=20,
    step=1,
    description='Recommendations:',
    disabled=False
)

# Función para mostrar las recomendaciones en una tabla interactiva
def show_recommendations(user_id, n_recommendations):
    recommendations = recommend_autoencoder(user_id, n_recommendations)

    # Convertir las recomendaciones en un DataFrame
    recommendations_df = pd.DataFrame(recommendations, columns=['Recommended Movies'])

    # Mostrar las recomendaciones como una tabla interactiva
    display(recommendations_df)

# Enlazar los widgets a la función de visualización
widgets.interactive(show_recommendations, user_id=user_selector, n_recommendations=recommendations_count)

"""#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
# **5. Sistema de recomendación de películas híbrido**
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
"""

# Crear las funciones y cargar las tablas necesarias
ratings = pd.read_sql("SELECT * FROM ratings_dt", con)  # Datos de calificaciones
movies = pd.read_sql("SELECT * FROM movies", con)  # Datos de películas
movies_genres = pd.read_sql("SELECT * FROM movies_genres", con)  # Géneros de películas

# Crear la matriz de usuario-producto
user_movie_matrix = ratings.pivot_table(index='userId', columns='movieId', values='rating').fillna(0)

# Filtrado colaborativo usando KNN para encontrar usuarios similares
knn = NearestNeighbors(metric='cosine', algorithm='brute')
knn.fit(user_movie_matrix.values)  # Entrenamos el modelo con la matriz de usuario-producto

# Filtrado basado en contenido con géneros
def recommend_content_based(movie_id, n_recommendations=10):
    genres_matrix = movies_genres.drop(columns=['movieId', 'title', 'year', '(no genres listed)'])
    cosine_sim = cosine_similarity(genres_matrix, genres_matrix)
    movie_idx = movies[movies['movieId'] == movie_id].index[0]

    sim_scores = list(enumerate(cosine_sim[movie_idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    movie_indices = [x[0] for x in sim_scores[1:n_recommendations+1]]
    recommended_movie_titles = movies['title'].iloc[movie_indices]
    return recommended_movie_titles

# Filtrado colaborativo usando KNN
def recommend_collaborative(user_id, n_recommendations=10):
    user_idx = user_movie_matrix.index.get_loc(user_id)
    distances, indices = knn.kneighbors(user_movie_matrix.iloc[user_idx, :].values.reshape(1, -1), n_neighbors=6)

    recommendations = {}
    for idx in indices[0][1:]:
        similar_user_ratings = user_movie_matrix.iloc[idx, :]
        for movie_id in similar_user_ratings[similar_user_ratings > 0].index:
            if user_movie_matrix.loc[user_id, movie_id] == 0:  # Si el usuario aún no ha visto la película
                recommendations[movie_id] = recommendations.get(movie_id, 0) + similar_user_ratings[movie_id]

    recommended_movies = sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:n_recommendations]

    recommended_movie_ids = [movie[0] for movie in recommended_movies]
    recommended_titles = movies[movies['movieId'].isin(recommended_movie_ids)]['title'].values
    return pd.DataFrame({'Movie Title': recommended_titles, 'Predicted Rating': [recommendations[movie[0]] for movie in recommended_movies]})

# Combinación híbrida de las recomendaciones
def hybrid_recommendation(user_id, movie_id, alpha=0.5, beta=0.5, n_recommendations=10):
    content_recs = recommend_content_based(movie_id, n_recommendations)
    collaborative_recs = recommend_collaborative(user_id, n_recommendations)['Movie Title']

    # Combinación simple de las recomendaciones
    combined_recs = list(set(content_recs) | set(collaborative_recs))  # Unión de recomendaciones
    return combined_recs[:n_recommendations]  # Devolver las 10 mejores recomendaciones combinadas

# Crear un widget de selección para el usuario
user_selector = widgets.Dropdown(
    options=[(user, user) for user in user_movie_matrix.index],
    description='User ID:',
    disabled=False
)

# Crear un widget de entrada para el ID de la película
movie_selector = widgets.Dropdown(
    options=[(title, movie_id) for movie_id, title in zip(movies['movieId'], movies['title'])],
    description='Movie ID:',
    disabled=False
)

# Crear un control para ajustar el número de recomendaciones
recommendations_count = widgets.IntSlider(
    value=10,
    min=1,
    max=20,
    step=1,
    description='Recommendations:',
    disabled=False
)

# Función para mostrar las recomendaciones en una tabla interactiva
def show_recommendations(user_id, movie_id, n_recommendations):
    recommendations = hybrid_recommendation(user_id, movie_id, alpha=0.5, beta=0.5, n_recommendations=n_recommendations)

    # Convertir las recomendaciones en un DataFrame
    recommendations_df = pd.DataFrame(recommendations, columns=['Recommended Movies'])

    # Mostrar las recomendaciones como una tabla interactiva
    display(recommendations_df)

# Enlazar los widgets a la función de visualización
widgets.interactive(show_recommendations, user_id=user_selector, movie_id=movie_selector, n_recommendations=recommendations_count)

"""#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
# 6.Sistema de recomendacion de filtro colaborativo basado en las calificaciones.
#/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////#
"""

# Función para recomendar películas basadas en calificaciones
def recommend_by_ratings(n_recommendations=10):
    # Calcular las películas con las mejores calificaciones promedio
    avg_ratings = ratings.groupby('movieId')['rating'].mean().reset_index()
    top_rated_movies = avg_ratings.sort_values(by='rating', ascending=False).head(n_recommendations)

    # Unir las calificaciones con los títulos de las películas
    top_rated_movies_with_titles = pd.merge(top_rated_movies, movies[['movieId', 'title']], on='movieId')

    # Mostrar las recomendaciones
    return top_rated_movies_with_titles[['title', 'rating']]

# Crear un control para ajustar el número de recomendaciones
recommendations_count = widgets.IntSlider(
    value=10,
    min=1,
    max=20,
    step=1,
    description='Recomendaciones:',
    disabled=False
)

# Función para mostrar las recomendaciones en una tabla interactiva
def show_recommendations(n_recommendations):
    recommendations = recommend_by_ratings(n_recommendations)

    # Mostrar las recomendaciones como una tabla
    display(recommendations)

# Enlazar el slider a la función de visualización
widgets.interactive(show_recommendations, n_recommendations=recommendations_count)