# -*- coding: utf-8 -*-
"""c_modelo1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z0XYS53Lzy1EMB-lwyHwCtnkg-kqwfl4
"""

# conexion a drive

from google.colab import drive
drive.mount('/content/drive')

import sys
import os

# Personalized path to your project directory
path = '/content/drive/MyDrive/cod/marketing/MarketingprojectG8/'

# Add the path to sys.path
sys.path.append(path)
os.chdir(path)

print(os.listdir())

"""# ***Librerias***

"""

#librerias
import numpy as np
import pandas as pd
import sqlite3 as sql
import plotly.graph_objs as go
from sklearn.preprocessing import MinMaxScaler
import plotly.express as px
from ipywidgets import interact ## para análisis interactivo
from sklearn import neighbors ### basado en contenido un solo producto consumido
import a_funciones as fn
import joblib

"""# ***Conexión a la base de datos***"""

#### conectar_base_de_Datos

con=sql.connect("movies2")
cur=con.cursor()

#### ver tablas disponibles en base de datos ###

cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
tables = cur.fetchall()

print("Tablas en la base de datos copiada:")
for table in tables:
    print(table)

cur.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='full_tabla'")
if not cur.fetchone():  # Si la tabla no existe
    with open('preprocesamiento.sql', 'r') as f:
        sql_script = f.read()
    cur.executescript(sql_script)
    con.commit()

"""#¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬#
###### **1.Sistemas basados en popularidad** ######
#¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬#

"""

#Top 10 peliculas más calificadas(mas vistas)
movies_top= pd.read_sql('''select title, count(*) as vistas
            from full_tabla
            group by title
            order by vistas desc limit 10''', con)

fig = px.bar(movies_top,
             x='title',
             y='vistas',
             title='Top 10 Películas Más Vistas',
             labels={'title': 'Película', 'vistas': 'Número de Vistas'},
             text='vistas',
             color='vistas',  # Color de las barras basado en el número de vistas
             color_continuous_scale=px.colors.sequential.Viridis)  # Escala de color

fig.update_traces(texttemplate='%{text:.2s}', textposition='outside')  # Formato del texto
fig.update_layout(xaxis_tickangle=-45,  # Inclinación de las etiquetas del eje x
                  xaxis_title_font=dict(size=14),
                  yaxis_title_font=dict(size=14),
                  title_font=dict(size=18))

fig.show()

#Top 10 peliculas mas vistas y su calificacion

top_movies = pd.read_sql('''select title, count(*) as vistas,avg(rating) as calificacion_promedio
            from full_tabla
            group by title
            order by vistas desc limit 10''', con)

top_movies

# Películas mejor calificadas con más de 50 calificaciones

top_rated = pd.read_sql("""
WITH RankedMovies AS (
    SELECT
        title,
        AVG(rating) AS avg_rating,
        COUNT(*) AS num_ratings
    FROM full_tabla
    GROUP BY title
    HAVING num_ratings > 50  -- Filter for movies with 50+ ratings
)
SELECT
    title,
    avg_rating,
    num_ratings
FROM RankedMovies
ORDER BY avg_rating DESC
LIMIT 10;
""", con)

top_rated

#Peliculas mejor calificadas por Año de estreno

rating_year=pd.read_sql('select year from full_tabla', con )
rating_year

def años(año = list(np.sort(rating_year['year'].unique(),kind="quicksort")[::-1])):
     texto= f"""select year, title,
            avg(rating) as promedio_cal,count(rating) as qty_cal
            from full_tabla where year={año} group by year,title order by promedio_cal desc limit 20"""
     print(pd.read_sql(texto, sql.connect('movies2')))

print(interact(años))

"""#¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬#
######2.1 Sistema de recomendación basado en contenido un solo producto - Manual######
#¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬#
"""

# Leer datos de la tabla 'movies_genres'
try:
  peliculas = pd.read_sql_query("SELECT * FROM movies_genres", con)
except sql.Error as e:
  print(f"Error al leer la tabla: {e}")

# Mostrar información del DataFrame
peliculas.info()

# Convertir la columna 'year' a tipo entero
peliculas = peliculas.astype({'year': 'int'})

# Escalamos los años de estreno de las peliculas

sc=MinMaxScaler()
peliculas[["year"]]=sc.fit_transform(peliculas[["year"]])

print(peliculas[['year']])

# Eliminamos columnas que no se van a usar

peliculas_dummy1=peliculas.drop(columns=['movieId','title'])
peliculas_dummy1

# Exportar esta base para usar en otro modelos
joblib.dump(peliculas_dummy1,"peliculas_dummy01")

from sklearn.metrics.pairwise import cosine_similarity

# Define la película objetivo
pelicula = 'Toy Story (1995)'

# Obtén el índice de la película objetivo
ind_peli = peliculas[peliculas['title'] == pelicula].index.values.astype(int)[0]

# Calcula la matriz de similitud del coseno
similarity_matrix = cosine_similarity(peliculas_dummy1)
similar_pelis = similarity_matrix[ind_peli]

# Crea un DataFrame con títulos y similitudes
similar_pelis_df = pd.DataFrame({'title': peliculas['title'], 'similarity': similar_pelis})

# Ordena por similitud y selecciona las 10 más similares
top_similar_pelis = similar_pelis_df.sort_values(by='similarity', ascending=False).head(11)

print(top_similar_pelis)

def recomendacion_alternativa(titulo_pelicula):
  """
  Recomienda películas similares basándose en la similitud del coseno de sus géneros.

  Args:
    titulo_pelicula: El título de la película para la que se buscan recomendaciones.

  Returns:
    Un DataFrame de Pandas con las 10 películas más similares.
  """
  # Obtener el índice de la película objetivo
  indice_pelicula = peliculas[peliculas['title'] == titulo_pelicula].index[0]

  # Calcular la similitud del coseno entre todas las películas
  similitudes = cosine_similarity(peliculas_dummy1)

  # Obtener las similitudes de la película objetivo con todas las demás
  similitudes_pelicula = similitudes[indice_pelicula]

  # Crear un DataFrame con los títulos y las similitudes
  df_similitudes = pd.DataFrame({'title': peliculas['title'], 'similarity': similitudes_pelicula})

  # Ordenar por similitud y obtener las 10 más similares (excluyendo la película objetivo)
  top_similares = df_similitudes[df_similitudes['title'] != titulo_pelicula].sort_values(by='similarity', ascending=False).head(10)

  return top_similares

# Crear la interfaz interactiva
print(interact(recomendacion_alternativa, titulo_pelicula=list(peliculas['title'])))

# ... (Asumiendo que 'peliculas' y 'peliculas_dummy1' ya están definidos) ...

# Crear peliculas_dummy2 eliminando la columna 'year'
peliculas_dummy2 = peliculas_dummy1.drop(columns=['year'])

# Película objetivo
pelicula_objetivo = 'Toy Story (1995)'

# Obtén los géneros de la película objetivo usando peliculas_dummy2
generos_objetivo = peliculas_dummy2.loc[peliculas['title'] == pelicula_objetivo].values[0]

# Calcula la similitud del coseno
similitudes = cosine_similarity([generos_objetivo], peliculas_dummy2)

# Crea un DataFrame con títulos y similitudes
df_similitudes = pd.DataFrame({'title': peliculas['title'], 'similarity': similitudes[0]})

# Ordena por similitud y selecciona las 10 más similares (excluyendo la película objetivo)
top_similares = df_similitudes[df_similitudes['title'] != pelicula_objetivo].sort_values(by='similarity', ascending=False).head(10)

print(top_similares)

def recomendaciones_similares(titulo_pelicula):
    """
    Recomienda películas similares basándose en la correlación de géneros.

    Args:
        titulo_pelicula: El título de la película para la que se buscan recomendaciones.

    Returns:
        Un DataFrame de Pandas con las 10 películas más similares.
    """

    # Obtener el índice de la película objetivo
    indice_pelicula = peliculas[peliculas['title'] == titulo_pelicula].index[0]

    # Calcular la similitud del coseno (similar a la correlación en este caso)
    similitudes = cosine_similarity(peliculas_dummy2, peliculas_dummy2.iloc[[indice_pelicula]])

    # Crear un DataFrame con los títulos y las similitudes
    df_similitudes = pd.DataFrame({'title': peliculas['title'], 'similarity': similitudes[:, 0]})

    # Ordenar por similitud y obtener las 10 más similares (excluyendo la película objetivo)
    top_similares = df_similitudes[df_similitudes['title'] != titulo_pelicula].sort_values(by='similarity', ascending=False).head(10)

    return top_similares

# Crear la interfaz interactiva
print(interact(recomendaciones_similares, titulo_pelicula=list(peliculas['title'])))

# Exportar esta base para usar en otro modelos
joblib.dump(peliculas_dummy2,"peliculas_dummy02")

"""#¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬#
######2.2 Sistema de recomendación basado en un solo producto- KNN ######
#¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬¬#
"""

## se entrena el modelo knn con la base de datos con año de estreno

# Creamos una instancia del modelo KNN con 11 vecinos y métrica coseno
model = neighbors.NearestNeighbors(n_neighbors=11, metric='cosine')

# Entrenamos el modelo utilizando los datos en 'peliculas_dummy1'
model.fit(peliculas_dummy1)

# Encontramos los 11 vecinos más cercanos para cada película en 'peliculas_dummy1'
# dist: matriz de distancias a los vecinos más cercanos
# idlist: matriz de índices de los vecinos más cercanos
dist, idlist = model.kneighbors(peliculas_dummy1)

# Convertimos la matriz de distancias a un DataFrame de Pandas
distancias = pd.DataFrame(dist)  # distancias de las 10 peliculas mas cercanas

# Convertimos la matriz de índices de vecinos a un DataFrame de Pandas
id_list = pd.DataFrame(idlist)  # se traducen las distancias al id de la pelicula que corresponde

def recomendar_peliculas(nombre_pelicula = list(peliculas['title'].unique())):
  """
  Recomienda películas similares usando KNN y datos de películas.

  Args:
    nombre_pelicula: El título de la película para la que se buscan recomendaciones.

  Returns:
    Una lista de títulos de películas recomendadas.
  """
  # Encontrar el índice de la película en el DataFrame
  indice_pelicula = peliculas[peliculas['title'] == nombre_pelicula].index[0]

  # Obtener los índices de las películas similares de idlist
  indices_similares = idlist[indice_pelicula]

  # Obtener los títulos de las películas similares usando los índices
  peliculas_recomendadas = [peliculas.loc[i]['title'] for i in indices_similares]

  # Excluir la película original de las recomendaciones
  peliculas_recomendadas = [p for p in peliculas_recomendadas if p != nombre_pelicula]

  return peliculas_recomendadas

# Crear el widget interactivo
print(interact(recomendar_peliculas, nombre_pelicula=list(peliculas['title'].unique())))

## Se entrena el modelo knn con la base de datos SIN año de estreno

# Crea una instancia del modelo KNN con 11 vecinos y métrica de similitud del coseno.
model = neighbors.NearestNeighbors(n_neighbors=11, metric='cosine')

# Entrena el modelo utilizando el DataFrame 'peliculas_dummy2' (sin la columna 'year').
model.fit(peliculas_dummy2)

# Encuentra los 11 vecinos más cercanos para cada película en 'peliculas_dummy2'.
dist, idlist = model.kneighbors(peliculas_dummy2)

# Convierte la matriz de distancias 'dist' en un DataFrame de Pandas llamado 'distancias'.
distancias = pd.DataFrame(dist)  # distancias de las 11 peliculas mas cercanas

# Convierte la matriz de índices de vecinos 'idlist' en un DataFrame de Pandas llamado 'id_list'.
id_list = pd.DataFrame(idlist)  # se traducen las distancias al id de la pelicula que corresponde

def MovieRecommender2(movie_name=list(peliculas['title'].value_counts().index)):
  """
  Recomienda películas similares utilizando el modelo KNN.

  Args:
      movie_name: El título de la película para la cual se buscan recomendaciones.
                   Por defecto, se usa la lista de películas más frecuentes.

  Returns:
      Una lista de títulos de películas recomendadas.
  """

  # Obtener el índice de la película en el DataFrame 'peliculas'
  movie_index = peliculas[peliculas['title'] == movie_name].index[0]

  # Obtener los índices de las películas similares del modelo KNN (idlist)
  similar_indices = idlist[movie_index]

  # Crear una lista con los títulos de las películas similares,
  # usando los índices para acceder al DataFrame 'peliculas'
  recommendations = [peliculas.loc[i, 'title'] for i in similar_indices]

  # Excluir la película original de la lista de recomendaciones
  recommendations = [movie for movie in recommendations if movie != movie_name]

  return recommendations

# Crear el widget interactivo con la nueva función
print(interact(MovieRecommender2))